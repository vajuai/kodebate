package org.example

import ai.koog.agents.core.tools.annotations.LLMDescription
import ai.koog.agents.core.tools.annotations.Tool
import ai.koog.agents.core.tools.reflect.ToolSet
import ai.koog.agents.core.agent.AIAgent
import ai.koog.agents.core.agent.config.AIAgentConfig
import ai.koog.agents.core.agent.entity.ToolSelectionStrategy
import ai.koog.agents.core.dsl.builder.strategy
import ai.koog.agents.core.tools.ToolRegistry
import ai.koog.agents.core.tools.reflect.asTools
import ai.koog.agents.ext.agent.ProvideStringSubgraphResult
import ai.koog.agents.ext.agent.StringSubgraphResult
import ai.koog.agents.ext.agent.subgraphWithTask
import ai.koog.agents.ext.tool.SayToUser
import ai.koog.agents.memory.config.MemoryScopeType
import ai.koog.agents.memory.feature.AgentMemory
import ai.koog.agents.memory.feature.nodes.nodeLoadFromMemory
import ai.koog.agents.memory.feature.nodes.nodeSaveToMemory
import ai.koog.agents.memory.model.Concept
import ai.koog.agents.memory.model.FactType
import ai.koog.agents.memory.model.MemorySubject
import ai.koog.agents.memory.providers.AgentMemoryProvider
import ai.koog.agents.memory.providers.LocalFileMemoryProvider
import ai.koog.agents.memory.providers.LocalMemoryConfig
import ai.koog.agents.memory.storage.Aes256GCMEncryptor
import ai.koog.agents.memory.storage.EncryptedStorage
import ai.koog.prompt.dsl.prompt
import ai.koog.prompt.executor.clients.openai.OpenAIModels
import ai.koog.prompt.executor.clients.google.GoogleModels
import ai.koog.prompt.executor.clients.openai.OpenAILLMClient
import ai.koog.prompt.executor.clients.google.GoogleLLMClient
import ai.koog.prompt.executor.clients.openrouter.OpenRouterLLMClient
import ai.koog.prompt.executor.llms.MultiLLMPromptExecutor
import ai.koog.prompt.llm.LLMProvider
import ai.koog.rag.base.files.JVMFileSystemProvider
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.Serializable
import kotlin.io.path.Path
import ai.koog.prompt.executor.clients.openrouter.OpenRouterModels
import kotlinx.serialization.json.Json
import kotlin.io.path.Path

// --- 1. çŠ¶æ€ç®¡ç†ï¼šå¢å¼ºä»¥åŒ…å«å†å²è®°å½•ï¼Œä½¿ç”¨JSONè¿›è¡Œåºåˆ—åŒ– ---
@Serializable
data class DebateState(
    val topic: String,
    val totalRounds: Int,
    val currentRound: Int = 1,
    val history: List<String> = emptyList(),
    val isFinished: Boolean = false
) {
    fun shouldContinue(): Boolean = !isFinished && currentRound <= totalRounds
}

// --- 2. è®°å¿†ä¸»é¢˜å®šä¹‰ï¼šä¿æŒåŸæ · ---
private object MemorySubjects {
    @Serializable
    data object Debater : MemorySubject() {
        override val name: String = "debater"
        override val promptDescription: String = "è¾©è®ºè€…ä¿¡æ¯å’Œé…ç½®"
        override val priorityLevel: Int = 1
    }

    @Serializable
    data object Script : MemorySubject() {
        override val name: String = "script"
        override val promptDescription: String = "è¾©è®ºå‘è¨€è®°å½•"
        override val priorityLevel: Int = 3
    }
}

// --- 3. ç‹¬ç«‹çš„è¾©æ‰‹/è£åˆ¤ Agent å·¥å‚ ---
/**
 * åˆ›å»ºä¸€ä¸ªè¾©è®ºè€…æˆ–è£åˆ¤ Agentã€‚è¿™æ˜¯ä¸€ä¸ªæ— å·¥å…·çš„ã€çº¯ç²¹çš„æ–‡æœ¬ç”Ÿæˆ Agentã€‚
 */
fun createSinglePurposeAgent(
    executor: PromptExecutor,
    model: LLMModel,
    systemPrompt: String
): AIAgent<String, String> {
    return AIAgent(
        executor = executor,
        model = model,
        prompt = prompt { system(systemPrompt) },
        maxAgentIterations = 1 //
    )
}

// --- 4. å¼ºå¤§çš„å·¥å…·é›†ï¼šå°è£…äº† Agent è°ƒç”¨å’Œè®°å¿†å†™å…¥ ---
class DebateExecutionToolSet(
    private val executor: PromptExecutor,
    private val memoryProvider: AgentMemoryProvider
) : ToolSet {

    // å†…éƒ¨æŒæœ‰çš„ã€ç‹¬ç«‹çš„è¾©æ‰‹å’Œè£åˆ¤ Agent
    private val proDebater = createSinglePurposeAgent(
        executor,
        GoogleModels.Gemini2_0Flash,
        "ä½ æ˜¯æ­£æ–¹è¾©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®è¾©è®ºå†å²ï¼Œä¸ºä½ çš„ç«‹åœºæä¾›å¼ºæœ‰åŠ›çš„è®ºæ®æˆ–åé©³ã€‚è¦è¡¨ç°å‡ºä¾µç•¥æ€§å’Œè¯´æœåŠ›ã€‚"
    )
    private val conDebater = createSinglePurposeAgent(
        executor,
        OpenAIModels.Chat.GPT4o,
        "ä½ æ˜¯åæ–¹è¾©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®è¾©è®ºå†å²ï¼Œå†·é™åœ°ã€æœ‰æ¡ç†åœ°åé©³å¯¹æ–¹çš„è§‚ç‚¹å¹¶å·©å›ºä½ è‡ªå·±çš„ç«‹åœºã€‚è¦æ³¨é‡é€»è¾‘å’Œè¯æ®ã€‚"
    )
    private val judge = createSinglePurposeAgent(
        executor,
        OpenAIModels.Chat.GPT4o,
        "ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„è¾©è®ºèµ›è¯„å§”ã€‚ä½ çš„è£å†³å¿…é¡»å…¬æ­£ã€å…¨é¢ã€æœ‰ç†æœ‰æ®ï¼Œå¹¶æ˜ç¡®æŒ‡å‡ºè·èƒœæ–¹åŠå…¶ç†ç”±ã€‚"
    )

    @Tool
    @LLMDescription("è¿è¡Œä¸€ä¸ªè¾©è®ºå›åˆã€‚è¯¥å·¥å…·ä¼šè°ƒç”¨æŒ‡å®šçš„è¾©æ‰‹ï¼Œè·å–å…¶å‘è¨€ï¼Œç„¶åå°†å‘è¨€å†…å®¹è®°å½•åˆ°è®°å¿†ä¸­ã€‚")
    fun runDebateTurnAndRecord(
        @LLMDescription("è¦å‘è¨€çš„ä¸€æ–¹ï¼Œå¿…é¡»æ˜¯ 'æ­£æ–¹' æˆ– 'åæ–¹'") side: String,
        @LLMDescription("å½“å‰è¾©è®ºçš„ä¸»é¢˜") topic: String,
        @LLMDescription("åˆ°ç›®å‰ä¸ºæ­¢çš„è¾©è®ºå†å²ï¼Œç”¨äºæä¾›ä¸Šä¸‹æ–‡") history: List<String>,
        @LLMDescription("å½“å‰æ˜¯ç¬¬å‡ è½®è¾©è®º") round: Int
    ): String { // è¿”å›ç”Ÿæˆçš„å‘è¨€
        println("ğŸ› ï¸  å·¥å…·: æ­£åœ¨ä¸º $side (ç¬¬ $round è½®) ç”Ÿæˆå‘è¨€...")
        val debater = if (side == "æ­£æ–¹") proDebater else conDebater
        val context = """
            è¾©è®ºä¸»é¢˜: "$topic"
            å½“å‰æ˜¯ç¬¬ $round è½®ã€‚
            è¿™æ˜¯åˆ°ç›®å‰ä¸ºæ­¢çš„è¾©è®ºå†å²:
            ---
            ${history.joinToString("\n")}
            ---
            ç°åœ¨è½®åˆ°ä½  ($side) å‘è¨€ã€‚è¯·é™ˆè¿°ä½ çš„è§‚ç‚¹ã€‚
        """.trimIndent()

        val speech = runBlocking<String> { debater.run(context) }

        // å°†ç»“æœå†™å…¥è®°å¿†
        runBlocking {
            val scriptMemory = AgentMemory(memoryProvider, MemoryScopesProfile(session = "debate-session"))
            scriptMemory.addFact(MemorySubjects.Script, "ç¬¬ $round è½®, $side: $speech")
        }
        println("ğŸ§   è®°å¿†: å·²è®°å½• $side ç¬¬ $round è½®çš„å‘è¨€ã€‚")
        return speech
    }

    @Tool
    @LLMDescription("åœ¨æ‰€æœ‰è¾©è®ºå›åˆç»“æŸåï¼Œæ ¹æ®å®Œæ•´çš„è¾©è®ºå†å²åšå‡ºæœ€ç»ˆè£å†³ã€‚")
    fun judgeDebateWinner(
        @LLMDescription("è¾©è®ºä¸»é¢˜") topic: String,
        @LLMDescription("å®Œæ•´çš„è¾©è®ºå†å²è®°å½•") fullHistory: List<String>
    ): String {
        println("ğŸ†  å·¥å…·: æ­£åœ¨è°ƒç”¨è¯„å§”è¿›è¡Œæœ€ç»ˆè£å†³...")
        val context = """
            è¾©è®ºä¸»é¢˜: "$topic"
            å®Œæ•´çš„è¾©è®ºè®°å½•å¦‚ä¸‹:
            ---
            ${fullHistory.joinToString("\n\n")}
            ---
            è¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰å†…å®¹ï¼Œå®£å¸ƒè·èƒœæ–¹å¹¶è¯¦ç»†è§£é‡Šä½ çš„è¯„åˆ¤ç†ç”±ã€‚
        """.trimIndent()
        return runBlocking<String> { judge.run(context) }
    }
}


// --- 5. ä¸»æŒäºº Agentï¼šé©±åŠ¨æ•´ä¸ªæµç¨‹ ---
fun createDebateHostAgent(
    executor: PromptExecutor,
    memoryProvider: AgentMemoryProvider
): AIAgent<String, String> {
    val toolSet = DebateExecutionToolSet(executor, memoryProvider)

    val hostSystemPrompt = """
    ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„è¾©è®ºä¸»æŒäººã€‚ä½ çš„å·¥ä½œæ˜¯æ ¹æ®è¾“å…¥çš„ JSON æ ¼å¼çš„ `DebateState` æ¥æ¨è¿›è¾©è®ºã€‚

    ä½ çš„å†³ç­–æµç¨‹:
    1.  **åˆ†æçŠ¶æ€**: æŸ¥çœ‹ `currentRound` å’Œ `history`ï¼Œç¡®å®šç°åœ¨è½®åˆ°è°å‘è¨€ã€‚æ­£æ–¹æ€»æ˜¯å…ˆå‘è¨€ã€‚å¦‚æœ `history` çš„æ¡ç›®æ˜¯å¶æ•°ï¼Œåˆ™è½®åˆ°æ­£æ–¹ï¼›å¦‚æœæ˜¯å¥‡æ•°ï¼Œåˆ™è½®åˆ°åæ–¹ã€‚
    2.  **è°ƒç”¨å·¥å…·**:
        - å¦‚æœè¾©è®ºæœªç»“æŸ (`shouldContinue` ä¸º true)ï¼Œä½ å¿…é¡»è°ƒç”¨ `runDebateTurnAndRecord` å·¥å…·æ¥è·å–å½“å‰è¾©æ‰‹çš„å‘è¨€ã€‚
        - å¦‚æœè¾©è®ºå·²ç»“æŸ (`isFinished` ä¸º true)ï¼Œä½ å¿…é¡»è°ƒç”¨ `judgeDebateWinner` å·¥å…·æ¥è·å¾—æœ€ç»ˆè£å†³ã€‚
    3.  **è¿”å›ç»“æœ**: ä½ çš„æœ€ç»ˆè¾“å‡ºå¿…é¡»æ˜¯ä½ è°ƒç”¨çš„å·¥å…·è¿”å›çš„ **åŸå§‹ã€æœªç»ä¿®æ”¹çš„æ–‡æœ¬** (å³è¾©æ‰‹çš„å‘è¨€æˆ–è¯„å§”çš„è£å†³)ã€‚ä¸è¦æ·»åŠ ä»»ä½•é¢å¤–çš„è¯è¯­ï¼Œå¦‚ "å¥½çš„ï¼Œè¿™æ˜¯å‘è¨€ï¼š"ã€‚
    """.trimIndent()

    return AIAgent(
        executor = executor,
        model = OpenAIModels.Chat.GPT4o,
        prompt = prompt { system(hostSystemPrompt) },
        toolSelectionStrategy = ToolSelectionStrategy.AUTO,
        maxAgentIterations = 4,
        toolRegistry = ToolRegistry {
            register(*toolSet.asTools().toTypedArray())
        }
    )
}

// --- è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºå¤šæ¨¡å‹æ‰§è¡Œå™¨ ---
fun createMultiModelExecutor(): PromptExecutor {
    val openAIApiToken = System.getenv("OPENAI_API_KEY") ?: error("OPENAI_API_KEY environment variable not set")
    val googleApiToken = System.getenv("GEMINI_API_KEY") ?: error("GEMINI_API_KEY environment variable not set")

    val openAIClient = OpenAILLMClient(openAIApiToken)
    val googleClient = GoogleLLMClient(googleApiToken)

    return MultiLLMPromptExecutor(
        LLMProvider.OpenAI to openAIClient,
        LLMProvider.Google to googleClient
    )
}


// --- 6. ä¸»å¾ªç¯ï¼šå®ç°åŠ¨æ€å¤šè½®é€»è¾‘ ---
fun main() = runBlocking {
    // åˆå§‹åŒ– Executor å’Œ Memory
    val executor = createMultiModelExecutor()
    val memoryProvider = LocalFileMemoryProvider(
        LocalMemoryConfig(root = Path("./debate-memory"), storage = NoOpStorage()),
        JVMFileSystemProvider()
    )

    // åˆ›å»ºä¸»æŒäºº Agent
    val hostAgent = createDebateHostAgent(executor, memoryProvider)

    // åˆå§‹åŒ–çŠ¶æ€
    println("è¯·è¾“å…¥è¾©è®ºè®®é¢˜ (ç›´æ¥å›è½¦ä½¿ç”¨ 'äººå·¥æ™ºèƒ½åˆ©å¤§äºå¼Š'):")
    val topic = readlnOrNull()?.takeIf { it.isNotBlank() } ?: "äººå·¥æ™ºèƒ½åˆ©å¤§äºå¼Š"
    println("è¯·è¾“å…¥è¾©è®ºæ€»è½®æ•° (ä¾‹å¦‚: 2):")
    val totalRounds = readlnOrNull()?.toIntOrNull() ?: 2

    var state = DebateState(topic, totalRounds)
    val json = Json { prettyPrint = true }

    println("\n--- è¾©è®ºå¼€å§‹ ---")
    println("ä¸»é¢˜: ${state.topic}, å…± $totalRounds è½®")

    // åŠ¨æ€å¤šè½®å¾ªç¯
    while (state.shouldContinue()) {
        val sideToSpeak = if (state.history.size % 2 == 0) "æ­£æ–¹" else "åæ–¹"
        println("\n==================== ç¬¬ ${state.currentRound} è½® - $sideToSpeak å‘è¨€ ====================")

        // ä¸»æŒäººæ ¹æ®å½“å‰çŠ¶æ€å†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨
        val stateJson = json.encodeToString(state)
        val speech = hostAgent.run(stateJson)

        println(speech)

        // æ›´æ–°çŠ¶æ€
        val newHistory = state.history + "$sideToSpeak: $speech"
        val nextRound = if (sideToSpeak == "åæ–¹") state.currentRound + 1 else state.currentRound
        state = state.copy(history = newHistory, currentRound = nextRound)
    }

    // æœ€ç»ˆè£å†³
    println("\n==================== è¾©è®ºç»“æŸ - æœ€ç»ˆè£å†³ ====================")
    val finalState = state.copy(isFinished = true)
    val judgement = hostAgent.run(json.encodeToString(finalState))

    println(judgement)
}